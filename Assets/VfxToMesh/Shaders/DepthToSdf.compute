#pragma kernel BakeDepthSdf

#define THREADS_3D 8

cbuffer DepthToSdfParams : register(b0)
{
    int _GridResolution;
    float _VoxelSize;
    float3 _BoundsMin;
    float3 _BoundsSize;
    float _SdfFar;
    float _DistanceScale;

    float4 _ViewOrigin;
    float4 _ViewRight;
    float4 _ViewUp;
    float4 _ViewForward;
    float2 _ViewSize;
    float _ViewNearClip;
    float _ViewFarClip;
    uint _ViewAxis;
};

Texture2D<float> _DepthTexture;
RWTexture3D<float> _SdfVolumeRW;
SamplerState linearClampSampler
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
    AddressW = Clamp;
};

uint3 MirrorIndex(uint3 id, uint axis)
{
    uint last = _GridResolution - 1;
    if (axis == 0)
    {
        id.x = last - id.x;
    }
    else if (axis == 1)
    {
        id.y = last - id.y;
    }
    else
    {
        id.z = last - id.z;
    }

    return id;
}

float SampleDepth(float2 uv)
{
    return _DepthTexture.SampleLevel(linearClampSampler, uv, 0);
}

[numthreads(THREADS_3D, THREADS_3D, THREADS_3D)]
void BakeDepthSdf(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= uint3(_GridResolution, _GridResolution, _GridResolution)))
    {
        return;
    }

    if (_ViewSize.x <= 0.0f || _ViewSize.y <= 0.0f)
    {
        _SdfVolumeRW[id] = _SdfFar;
        return;
    }

    float range = _ViewFarClip - _ViewNearClip;
    if (range <= 0.0f)
    {
        _SdfVolumeRW[id] = _SdfFar;
        return;
    }

    float3 voxelWorld = _BoundsMin + (float3(id) + 0.5f) * _VoxelSize;

    float2 uv = 0.5f + float2(dot(voxelWorld - _ViewOrigin.xyz, _ViewRight.xyz) / _ViewSize.x,
                                 dot(voxelWorld - _ViewOrigin.xyz, _ViewUp.xyz) / _ViewSize.y);

    uint3 writeId = MirrorIndex(id, _ViewAxis);

    if (uv.x < 0.0f || uv.x > 1.0f || uv.y < 0.0f || uv.y > 1.0f)
    {
        _SdfVolumeRW[writeId] = _SdfFar;
        return;
    }

    float depthNormalized = saturate(SampleDepth(uv));
    float depthWorld = _ViewNearClip + depthNormalized * range;
    float pointDepth = dot(voxelWorld - _ViewOrigin.xyz, _ViewForward.xyz);
    float signedDistance = pointDepth - depthWorld;
    float normalizedDistance = clamp(signedDistance * _DistanceScale, -_SdfFar, _SdfFar);
    _SdfVolumeRW[writeId] = normalizedDistance;
}
