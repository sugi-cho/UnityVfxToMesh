#pragma kernel ClearSdf
#pragma kernel StampParticles

#define THREADS_1D 256
#define THREADS_3D 8

cbuffer VfxToSdfCommon : register(b0)
{
    uint _ParticleCount;
    uint _GridResolution;
    uint _CellResolution;
    float _VoxelSize;
    float3 _BoundsMin;
    float3 _BoundsSize;
    float _IsoValue;
    float _SdfFar;
    float4x4 _LocalToWorld;
    float4x4 _WorldToLocal;
    float _ColorRadiusMultiplier;
    float _ColorFadeMultiplier;
}

StructuredBuffer<float4> _Particles;            // xyz: position, w: radius
StructuredBuffer<float4> _ParticleColors;       // xyz: color, w: alpha
RWTexture3D<float> _SdfVolumeRW;
RWTexture3D<float4> _ColorVolumeRW;

float3 NormalizeWorldToUv(float3 world)
{
    return (world - _BoundsMin) / _BoundsSize;
}

[numthreads(THREADS_3D, THREADS_3D, THREADS_3D)]
void ClearSdf(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    if (any(dispatchThreadId >= uint3(_GridResolution, _GridResolution, _GridResolution)))
        return;
    _SdfVolumeRW[dispatchThreadId] = _SdfFar;
    _ColorVolumeRW[dispatchThreadId] = float4(0, 0, 0, 0);
}

[numthreads(THREADS_1D, 1, 1)]
void StampParticles(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint id = dispatchThreadId.x;
    if (id >= _ParticleCount)
        return;

    float4 particle = _Particles[id];
    float3 pos = particle.xyz;
    float radius = particle.w;

    if (radius <= 0.0f)
        return;

    float padding = _VoxelSize * 2.0f; // ensure gradient sampling has valid neighbors
    float support = radius + padding;
    float3 minBounds = pos - support;
    float3 maxBounds = pos + support;

    int3 minCoord = clamp((int3)floor((minBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);
    int3 maxCoord = clamp((int3)ceil((maxBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);

    for (int z = minCoord.z; z <= maxCoord.z; ++z)
    {
        for (int y = minCoord.y; y <= maxCoord.y; ++y)
        {
            for (int x = minCoord.x; x <= maxCoord.x; ++x)
            {
                float3 voxelWorld = _BoundsMin + (float3(x, y, z) + 0.5f) * _VoxelSize;
                float dist = length(voxelWorld - pos) - radius;
                float current = _SdfVolumeRW[int3(x, y, z)];
                if (dist < current)
                {
                    _SdfVolumeRW[int3(x, y, z)] = dist;
                }
            }
        }
    }

    float4 particleColor = _ParticleColors[id];
    float3 colorRgb = particleColor.rgb;
    float baseWeight = particleColor.a;
    float colorRadius = radius * _ColorRadiusMultiplier;
    float fadeRadius = max(colorRadius, radius * _ColorFadeMultiplier);
    if (baseWeight <= 0 || fadeRadius <= 0)
    {
        return;
    }

    float3 colorMinBounds = pos - fadeRadius;
    float3 colorMaxBounds = pos + fadeRadius;
    int3 colorMinCoord = clamp((int3)floor((colorMinBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);
    int3 colorMaxCoord = clamp((int3)ceil((colorMaxBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);

    for (int z = colorMinCoord.z; z <= colorMaxCoord.z; ++z)
    {
        for (int y = colorMinCoord.y; y <= colorMaxCoord.y; ++y)
        {
            for (int x = colorMinCoord.x; x <= colorMaxCoord.x; ++x)
            {
                float3 voxelWorld = _BoundsMin + (float3(x, y, z) + 0.5f) * _VoxelSize;
                float dist = length(voxelWorld - pos);
                if (dist > fadeRadius)
                {
                    continue;
                }

                float coverage = dist <= colorRadius ? 1.0f :
                    saturate(colorRadius == fadeRadius ? 0.0f : (fadeRadius - dist) / (fadeRadius - colorRadius));
                float weight = baseWeight * coverage;
                if (weight <= 0.0f)
                {
                    continue;
                }

                float4 currentColor = _ColorVolumeRW[int3(x, y, z)];
                float existingWeight = currentColor.a;
                float totalWeight = clamp(existingWeight + weight, 0.0f, 1.0f);
                float blendFactor = totalWeight > 0.0f ? weight / totalWeight : 0.0f;
                float3 blended = lerp(currentColor.rgb, colorRgb, blendFactor);
                _ColorVolumeRW[int3(x, y, z)] = float4(blended, totalWeight);
            }
        }
    }
}
