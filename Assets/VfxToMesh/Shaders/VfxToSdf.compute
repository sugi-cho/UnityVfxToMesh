#pragma kernel ClearSdf
#pragma kernel StampParticles
#pragma kernel ClearParticleBuffers
#pragma kernel NormalizeColorVolume

#define THREADS_1D 256
#define THREADS_3D 8

cbuffer VfxToSdfCommon : register(b0)
{
    uint _ParticleCount;
    uint _GridResolution;
    uint _CellResolution;
    float _VoxelSize;
    float3 _BoundsMin;
    float3 _BoundsSize;
    float _IsoValue;
    float _SdfFar;
    float4x4 _LocalToWorld;
    float4x4 _WorldToLocal;
    float _SdfRadiusMultiplier;
    float _SdfFadeMultiplier;
    float _ColorRadiusMultiplier;
    float _ColorFadeMultiplier;
    float _SmoothFactor;
    float _DistanceScale;
}

RWStructuredBuffer<float4> _Particles;            // xyz: position, w: radius
RWStructuredBuffer<float4> _ParticleColors;       // xyz: color, w: alpha
RWTexture3D<float> _SdfVolumeRW;
RWTexture3D<float4> _ColorVolumeRW;

float3 NormalizeWorldToUv(float3 world)
{
    return (world - _BoundsMin) / _BoundsSize;
}

float SmoothUnion(float current, float candidate, float k)
{
    float h = saturate(0.5 + 0.5 * (candidate - current) / k);
    return lerp(candidate, current, h) - k * h * (1.0 - h);
}

[numthreads(THREADS_3D, THREADS_3D, THREADS_3D)]
void ClearSdf(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    if (any(dispatchThreadId >= uint3(_GridResolution, _GridResolution, _GridResolution)))
        return;
    _SdfVolumeRW[dispatchThreadId] = _SdfFar;
    _ColorVolumeRW[dispatchThreadId] = float4(0, 0, 0, 0);
}

[numthreads(THREADS_1D, 1, 1)]
void StampParticles(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint id = dispatchThreadId.x;
    if (id >= _ParticleCount)
        return;

    float4 particle = _Particles[id];
    float3 pos = particle.xyz;
    float radius = particle.w;

    if (radius <= 0.0f)
        return;

    float sdfRadius = radius * _SdfRadiusMultiplier;
    float sdfFade = max(sdfRadius, radius * _SdfFadeMultiplier);
    float3 minBounds = pos - sdfFade;
    float3 maxBounds = pos + sdfFade;

    int3 minCoord = clamp((int3)floor((minBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);
    int3 maxCoord = clamp((int3)ceil((maxBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);

    for (int z = minCoord.z; z <= maxCoord.z; ++z)
    {
        for (int y = minCoord.y; y <= maxCoord.y; ++y)
        {
            for (int x = minCoord.x; x <= maxCoord.x; ++x)
            {
                float3 voxelWorld = _BoundsMin + (float3(x, y, z) + 0.5f) * _VoxelSize;
                float3 delta = voxelWorld - pos;
                float len = length(delta);
                if (len > sdfFade)
                {
                    continue;
                }
                float dist = len - radius;
                int3 voxelIdx = int3(x, y, z);
                float current = _SdfVolumeRW[voxelIdx];
                float k = max(_SmoothFactor, 0.0001);
                bool useSmoothUnion = _SmoothFactor >= 0.1;
                float normalizedDist = dist * _DistanceScale;
                float unionDist = useSmoothUnion ? SmoothUnion(current, normalizedDist, k) : normalizedDist;
                if (unionDist < current)
                {
                    _SdfVolumeRW[voxelIdx] = unionDist;
                }
            }
        }
    }

    float4 particleColor = _ParticleColors[id];
    float3 colorRgb = particleColor.rgb;
    float baseWeight = particleColor.a;
    float colorRadius = radius * _ColorRadiusMultiplier;
    float fadeRadius = max(colorRadius, radius * _ColorFadeMultiplier);
    if (baseWeight <= 0 || fadeRadius <= 0)
    {
        return;
    }

    float3 colorMinBounds = pos - fadeRadius;
    float3 colorMaxBounds = pos + fadeRadius;
    int3 colorMinCoord = clamp((int3)floor((colorMinBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);
    int3 colorMaxCoord = clamp((int3)ceil((colorMaxBounds - _BoundsMin) / _VoxelSize), 0, (int)_GridResolution - 1);

    for (int cz = colorMinCoord.z; cz <= colorMaxCoord.z; ++cz)
    {
        for (int cy = colorMinCoord.y; cy <= colorMaxCoord.y; ++cy)
        {
            for (int cx = colorMinCoord.x; cx <= colorMaxCoord.x; ++cx)
            {
                float3 voxelWorld = _BoundsMin + (float3(cx, cy, cz) + 0.5f) * _VoxelSize;
                float dist = length(voxelWorld - pos);
                if (dist > fadeRadius)
                {
                    continue;
                }

                float weight = baseWeight;
                if (weight <= 0.0f)
                {
                    continue;
                }

                int3 voxelIdx = int3(cx, cy, cz);
                float4 currentColor = _ColorVolumeRW[voxelIdx];
                float3 sumColor = currentColor.rgb + colorRgb * weight;
                float sumAlpha = currentColor.a + weight;
                _ColorVolumeRW[voxelIdx] = float4(sumColor, sumAlpha);
            }
        }
    }
}

[numthreads(THREADS_3D, THREADS_3D, THREADS_3D)]
void NormalizeColorVolume(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    if (any(dispatchThreadId >= uint3(_GridResolution, _GridResolution, _GridResolution)))
        return;

    float4 data = _ColorVolumeRW[dispatchThreadId];
    float alpha = data.a;
    if (alpha <= 0.0f)
    {
        _ColorVolumeRW[dispatchThreadId] = float4(0, 0, 0, 0);
        return;
    }

    float3 normalized = data.rgb / alpha;
    _ColorVolumeRW[dispatchThreadId] = float4(normalized, alpha);
}

[numthreads(THREADS_1D, 1, 1)]
void ClearParticleBuffers(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint id = dispatchThreadId.x;
    if (id >= _ParticleCount)
        return;

    _Particles[id] = float4(0, 0, 0, -1);
    _ParticleColors[id] = float4(0, 0, 0, 0);
}
